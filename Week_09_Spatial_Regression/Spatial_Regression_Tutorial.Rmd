---
title: "Tutorial: Spatial Regression in R"
subtitle: "Assessing Autocorrelation, Modeling Correlation Structures, and Spatial Autoregressive Models"
author: "Laura Ryge Koch"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    theme: cosmo
    highlight: tango
    number_sections: true
editor_options: 
  chunk_output_type: console
bibliography: references.bib
link-citations: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, warning = FALSE, message = FALSE, error = TRUE)
```

# Introduction

Welcome to this tutorial on spatial regression! Spatial data often violates the independence assumption of classical regression because observations close in space tend to be more similar than those far apart. This tutorial will guide you through:

- **Detecting spatial autocorrelation** using Moran's I and semivariograms
- **Fitting basic regression models** and assessing residuals
- **Incorporating spatial correlation structures** into mixed-effects models
- **Comparing different spatial correlation models**
- **Evaluating model performance** and reporting findings

We'll use vegetation data from the **sPlotOpen** database, focusing on European plant communities to understand how environmental factors influence species richness while accounting for spatial dependencies.

## Learning Objectives

By the end of this tutorial, you will be able to:

1. Detect violations of independence due to spatial autocorrelation
2. Assess spatial autocorrelation in model residuals
3. Fit mixed-effects models with spatial correlation structures
4. Compare exponential, Gaussian, and spherical correlation structures
5. Evaluate and select optimal models using AIC and likelihood ratio tests
6. Interpret and report spatial regression results

### Some Information on the Data-set Used

The data you'll be working with in this computer lab comes from a project called [*sPlot*](https://www.idiv.de/en/sdiv/working_groups/wg_pool/splot/about_the_project.html), an initiative of the [German Centre for Integrative Biodiversity Research (iDiv)](https://www.idiv.de/en/index.html). The complete *sPlot* database covers a wide range of locations but has uneven coverage and is not publicly available. However, [@sabatini2021] addressed these issues by carefully selecting, organising, and obtaining permission from data owners of 105 different local and regional data-sets to make some of them open to the public. This led to the creation of **sPlotOpen**, the largest freely available collection of plot-based vegetation data. This data-set can be used to study global plant diversity, assist with remote sensing tasks, or track biodiversity changes over time.

*sPlotOpen* contains data from around the world. We use a European subset of the data for this session —sites with over ten species and sampling areas above 10m^2^. For each site, data includes species richness (number of different species per plot - `Species_richness`), location (longitude and latitude - `Longitude`,`Latitude`), country (`Country`), plot size (in square meters- `Releve_area`), geographical features (elevation, slope, aspect - `Elevation`, `Aspect`, and `Slope`), and environmental variables (loading on Principal Component axes 1 and 2 (`SoilClim_PC1`,`SoilClim_PC2`) based on climate and soil conditions derived by [@sabatini2021], and the [Environmental Stratification Class](https://www.wur.nl/en/research-results/research-institutes/environmental-research/projects/ebone/products/european-environmental-stratification.htm) - `Env.Strat`; derived by [@metzger2005]).

## Essential Functions Reference

| Task | Function | Package |
|------|----------|---------|
| Linear model | `lm()` | stats |
| GLS model | `gls()` | nlme |
| Mixed-effects model | `lme()` | nlme |
| Moran's I | `Moran.I()` | ape |
| Moran's I test | `moran.test()` | spdep |
| Moran plot | `moran.plot()` | spdep |
| Neighbors | `knn2nb()`, `knearneigh()` | spdep |
| Weights | `nb2listw()` | spdep |
| Variogram | `Variogram()` | nlme |
| Variogram | `variogram()` | gstat |
| Exponential correlation | `corExp()` | nlme |
| Gaussian correlation | `corGaus()` | nlme |
| Spherical correlation | `corSpher()` | nlme |
| Model comparison | `AIC()`, `anova()` | stats |
| Cross-validation | `train()`, `trainControl()` | caret |
---

# Part 1: Data Preparation and Exploration

## 1.1 Load Required Packages

```{r load-packages}
# Load packages for spatial analysis
library(nlme)     # For mixed-effects models with spatial correlation
library(dplyr)     # For data manipulation
library(ggplot2)     # For visualization
library(sf)     # For simple features (spatial data)
library(spdep)     # For spatial weights and Moran's I
library(gstat)     # For geostatistics and variograms
library(ape)     # For phylogenetic statistics (includes Moran.I)
library(sp)     # For spatial classes
library(lmtest)     # For testing heteroscedasticity
library(caret)     # For k-fold validation
```

**HINT:** Packages needed are: `nlme`, `dplyr`, `ggplot2`, `sf`, `spdep`, `gstat`, `ape`, `sp`, `lmtest`,`caret`

## 1.2 Load and Explore the Data

```{r load-data}
# Load the sPlot data
sPlot.Data <- read.csv("Splot_SppRichness.csv")

# Explore data structure
str(sPlot.Data)

# View summary statistics
summary(sPlot.Data)

# Check the first few rows
head(sPlot.Data)
```

**TASK:** Fill in functions to read CSV files, examine structure, summarize, and view the first rows.

## 1.3 Data Cleaning and Standardization

```{r clean-data}
# Remove missing values
sPlot.Data <- na.omit(sPlot.Data)

# Standardize continuous predictors
sPlot.Data$Elevation <- scale(sPlot.Data$Elevation)
sPlot.Data$Slope <- scale(sPlot.Data$Slope)
```

**TASK:** Fill in the function to remove NAs and the function to standardize variables (z-scores).

## 1.4 Visualize Spatial Distribution

```{r visualize-spatial}
# Create a basic spatial plot of species richness
ggplot(sPlot.Data) +
  geom_point(aes(x = Longitude, y = Latitude, color = Species_richness)) +
  scale_color_viridis_c() +
  theme_minimal() +
  labs(title = "Spatial Distribution of Species Richness",
       x = "Longitude", y = "Latitude")
```

**TASK:** Fill in the geom function for points and the aesthetic mappings (x, y, color).

```{r visualize-sf}
# Convert to sf object for better spatial visualization
data_sf <- st_as_sf(x = sPlot.Data, 
                 coords = c("Longitude", "Latitude"), 
                 crs = 4326)

# Plot using geom_sf
ggplot(data_sf) +
  geom_sf(aes(color=Species_richness)) +
  scale_color_viridis_c() +
  theme_minimal() +
  labs(title = "Spatial Distribution of Species Richness")
```

**TASK:** Fill in the function to create sf objects, its arguments (data, coords, crs), coordinate column names, and the geom for sf objects.

---

# Part 2: Detecting Spatial Autocorrelation

## 2.1 Understanding Spatial Autocorrelation Concepts

**Key Concepts:**

- **Spatial Autocorrelation**: The correlation of a variable with itself through space
  - *Positive*: Similar values cluster together (high near high, low near low)
  - *Negative*: Dissimilar values are neighbors (high near low)
  - *Zero*: Random spatial pattern

- **Moran's I**: Quantifies spatial autocorrelation
  - Ranges from -1 (dispersion) to +1 (clustering)
  - Values near 0 suggest randomness

- **Semivariogram**: Shows how similarity decreases with distance
  - *Nugget*: Variability at zero distance (measurement error)
  - *Range*: Distance where correlation diminishes
  - *Sill*: Plateau indicating total variance

## 2.2 Calculate Moran's I

### Method 1: Using the `ape` package

```{r morans-i-ape}
# Create coordinate matrix
coords <- cbind(sPlot.Data$Longitude, sPlot.Data$Latitude)

# Calculate distance matrix
dist_matrix <- as.matrix(dist(coords))

# Create inverse distance weight matrix
inv_dist_matrix <- 1 / dist_matrix
diag(inv_dist_matrix) <- 0  # Set diagonal to 0

# Calculate Moran's I using ape
library(ape)
moran_result <- Moran.I(x = sPlot.Data$Species_richness,
                      weight = inv_dist_matrix,
                      scaled = TRUE,
                      na.rm = TRUE)

# Display results
print(moran_result)
```

**TASK:** Fill in functions to combine columns, calculate distances, and compute Moran's I with appropriate arguments.

### Method 2: Using the `spdep` package

```{r morans-i-spdep}
# Create neighbor structure (4 nearest neighbors)
library(spdep)
nb <- knn2nb(knearneigh(coords, k = 4))

# Create spatial weights list
listw <- nb2listw(nb, style = "W")

# Compute Moran's I test
moran.test(x = sPlot.Data$Species_richness, 
          listw = listw)
```

**TASK:** Fill in functions to create k-nearest neighbors, convert to neighbor list, create weights, and perform Moran's test.

## 2.3 Visualize Moran's I with a Moran Plot

A Moran scatterplot showing relationship between a variable and the average value of its neighbors for the same variable 
It is instructive to consider each quadrant of the plot. In the upper-right quadrant are cases where both the value and local average value of the attribute are higher than the overall average value. Similarly, in the lower-left quadrant are cases where both the value and local average value of the attribute are lower than the overall average value. These cases confirm positive spatial autocorrelation. Cases in the other two quadrants indicate negative spatial autocorrelation. Depending on which groups are dominant, there will be an overall tendency towards positive or negative (or perhaps no) spatial autocorrelation.

```{r moran-plot-manual}
# Create Moran plot data manually (using ape approach)
DataMoranPlot <- data.frame(
  LaggedValues = scale(as.numeric(inv_dist_matrix %*% sPlot.Data$Species_richness)),
  StandardizedValues = scale(sPlot.Data$Species_richness)
)

# Create Moran plot
plot(LaggedValues ~ StandardizedValues, 
     data = DataMoranPlot,
     main = "Moran Plot",
     xlab = "Standardized Values", 
     ylab = "Spatially Lagged Values")
abline(h = 0, v = 0, col = "gray")
abline(lm(LaggedValues ~ StandardizedValues, data = DataMoranPlot), 
       col = "red")
```

**TASK:** Fill in the formula notation for the plot and the function to fit a linear model. 


```{r moran-plot-spdep}
# Moran plot using spdep
moran.plot(x = sPlot.Data$Species_richness, 
          listw = listw,
          main = "Moran Plot of Species Richness")
```

**TASK:** Fill in the function and arguments for creating a Moran plot.

## 2.4 Interpret Moran's I Results

**Your Interpretation:**

- Moran I Statistic: 0.2298 (fill in the value from your output)
- P-value: 2.2e-16 (fill in the value)
- Conclusion: Is there significant spatial autocorrelation? (Yes/No) Yes
- Type: Is it positive or negative autocorrelation? Positive
- Implication: What does this mean for your analysis? Species richness values are more similar in nearby locations than what we would expect by chance. Areas with high richness tend to be near other high-richness areas, and low-richness also cluster- This indicates spatial autocorrelation rather than random spatial patterns.

---

# Part 3: Basic Linear Regression and Residual Analysis

## 3.1 Fit a Basic Linear Model

```{r fit-lm}
# Fit linear model without spatial components
lm_model <- lm(Species_richness ~ Elevation + Slope + SoilClim_PC1 + SoilClim_PC2,
                  data = sPlot.Data)

# View model summary
summary(lm_model)
```

**TASK:** Fill in the function to fit linear models, the response variable, and the dataset.

## 3.2 Diagnostic Plots

```{r diagnostic-plots}
# Create diagnostic plots
par(mfrow = c(2, 2))
plot(lm_model)
```

**TASK:** Fill in the function to create diagnostic plots.

## 3.3 Test for Heteroscedasticity

A formal statistical test you can use to determine if heteroscedasticity is present is the Breusch-Pagan test. The test uses the following null and alternative hypotheses:

* Null Hypothesis (H0): Homoscedasticity is present (the residuals are distributed with equal variance)
* Alternative Hypothesis (HA): Heteroscedasticity is present (the residuals are not distributed with equal variance)

If the $p$-value of the test is less than some significance level (i.e. $\alpha$ = 0.05) then we reject the null hypothesis and conclude that heteroscedasticity is present in the regression model.

```{r test-heteroscedasticity}
# Breusch-Pagan test for heteroscedasticity
library(lmtest)
bptest(lm_model)
```

**TASK:** Fill in the function to perform the Breusch-Pagan test.

## 3.4 Test Residuals for Spatial Autocorrelation

```{r residual-moran}
# Extract residuals
lm_residuals <- resid(lm_model)

# Moran's I on residuals (using ape)
Moran.I(x = lm_residuals,
     weight = inv_dist_matrix,
     scaled = TRUE,
     na.rm = TRUE)

# Moran's I on residuals (using spdep)
moran.test(x = lm_residuals, 
          listw = listw)
```

**TASK:** Fill in functions to extract residuals and compute Moran's I on residuals.

**Question:** Do the residuals show spatial autocorrelation? What does this indicate about the model? yes, resids show spatial autocorrelation --> linear model did not fully account for spatial structure in species richness

---

# Part 4: Semivariogram Analysis

## 4.1 Fit a GLS Model for Variogram Analysis

```{r fit-gls}
# Fit generalized least squares model
library(nlme)
gls_model <- gls(Species_richness ~ Elevation + Slope + SoilClim_PC1 + SoilClim_PC2,
                   data = sPlot.Data)

# View summary
summary(gls_model)
```

**TASK:** Fill in the function to fit GLS models, the formula, and dataset.

## 4.2 Calculate and Plot Variogram (Method 1: nlme)

```{r variogram-nlme}
# Estimate variogram from GLS model
Vario1 <- Variogram(object = gls_model,
                form = ~ Longitude + Latitude,
                robust = TRUE,
                maxDist = 0.5,
                resType = "normalized")

# Plot variogram
plot(Vario1, smooth = TRUE)
```

**TASK:** Fill in the function to calculate variogram, its arguments, coordinate names, and plotting function.

## 4.3 Calculate and Plot Variogram (Method 2: gstat)

```{r variogram-gstat}
# Add residuals to data
sPlot.Data$residuals <- resid(gls_model)

# Convert to spatial object
library(sp)
sPlot.Spat <- sPlot.Data
coordinates(sPlot.Spat) <- ~ Longitude + Latitude

# Calculate variogram
library(gstat)
# Use Cressie–Hawkins robust estimator (optional, for outlier resistance)
Gstat_variogram <- variogram(residuals ~ 1, 
                             data = sPlot.Spat, 
                             cutoff = 1, # adjust to see plateau
                             width = 0.05,      # adjust lag bin width as needed
                             cressie = TRUE)

# --- Fit a theoretical variogram model ---
# Initial guess for parameters: adjust psill, range, and nugget to your data scale
vgm_model_init <- vgm(psill = var(sPlot.Spat$residuals, na.rm = TRUE) * 0.8,
                      model = "Exp", 
                      range = 0.2, 
                      nugget = var(sPlot.Spat$residuals, na.rm = TRUE) * 0.2)

# Fit model to empirical variogram
Gstat_fit <- fit.variogram(Gstat_variogram, vgm_model_init)

# --- Plot results ---
plot(Gstat_variogram, Gstat_fit, 
     main = "Empirical and Fitted Variogram (gstat)",
     xlab = "Distance", 
     ylab = "Semivariance")
```

**TASK:** Fill in functions to extract residuals, set coordinates (using the special assignment operator), and calculate variogram.

## 4.4 Interpret the Semivariogram

**Your Interpretation:**

1. What is the nugget (intercept at distance 0)? 0.026
2. What is the approximate range (distance where it plateaus)? 0.5 ish I would say
3. What is the sill (plateau value)? around 0.4
4. Does the variogram suggest spatial autocorrelation? yes, i think... empirical semivariance increases with distance and then plateaus = indicates positive spatial autocorrelation at short distances (points closer to each other have more similar residuals than points farther apart) google says: If there were no spatial structure, the points would form a flat band with no systematic increase.
5. What spatial structure is indicated? observations closer than ~0.5 distance units are more similar --> gradual decrease of spatial correlation with distance

---

# Part 5: Mixed-Effects Models with Spatial Correlation Structures

## 5.1 Understanding Spatial Correlation Structures

**Three Common Structures:**

1. **Exponential** (`corExp`):
   - Rapid initial decay, long tails
   - Correlation gradually decreases with distance
   - Good for moderate to strong short-range autocorrelation

2. **Gaussian** (`corGaus`):
   - Smooth, rapid decay
   - Correlation drops to zero quickly
   - Good for smooth spatial patterns

3. **Spherical** (`corSpher`):
   - Linear increase in semivariance, then levels off
   - Has a defined range beyond which correlation is zero
   - Good for processes with finite spatial influence

## 5.2 Fit Model with Exponential Correlation Structure

```{r fit-exponential}
# Fit mixed-effects model with exponential spatial correlation
exponential_model <- lme(Species_richness ~ Elevation + Slope + SoilClim_PC1 + SoilClim_PC2,
                           random = ~ 1 | Country,  # Random intercept by Country
                           correlation = corExp(form = ~ Longitude + Latitude),
                           data = sPlot.Data)
# View summary
summary(exponential_model)

# Compare to basic GLS
anova(exponential_model, gls_model) #lme is best
```

**TASK:** Fill in the function for mixed-effects models, response variable, random effect grouping variable, correlation structure function, coordinate formula, dataset, and comparison function.

## 5.3 Fit Model with Gaussian Correlation Structure

```{r fit-gaussian}
# Update with Gaussian correlation structure
gaussian_model <- update(object = exponential_model, 
                        correlation = corGaus(form = ~ Longitude + Latitude))

# View summary
summary(gaussian_model)

# Compare to GLS
anova(gaussian_model, gls_model)
```

**TASK:** Fill in the function to update models and the Gaussian correlation structure function.

## 5.4 Fit Model with Spherical Correlation Structure

```{r fit-spherical}
# Update with Spherical correlation structure
spherical_model <- update(exponential_model, 
                          correlation = corSpher(form = ~ Longitude + Latitude))

# View summary
summary(spherical_model)

# Compare to GLS
anova(spherical_model, gls_model)
```

**TASK:** Fill in the spherical correlation function and coordinate formula.

---

# Part 6: Model Comparison and Selection

## 6.1 Compare Models Using AIC

```{r compare-aic}
# Compare all models using AIC
AIC(spherical_model, gaussian_model, exponential_model, gls_model)
```

**TASK:** Fill in the function to calculate AIC and the four model objects to compare.

## 6.2 Likelihood Ratio Tests

```{r compare-lrt}
# Likelihood ratio test comparing spatial models
anova(spherical_model, exponential_model, gaussian_model)
```

**TASK:** Fill in the function to perform ANOVA comparison of multiple models.

## 6.3 Summarize Model Comparison

Create a table summarizing the model comparison:


| Model | df | AIC | BIC | logLik | Best? |
|-------|-----|-----|-----|--------|-------|
| GLS (no spatial) | 6  | -284.5947  | -256.0045  | 148.2974  | No |
| Exponential | 8  | -355.5954  | -317.4751  | 185.7977  | Yes (lowest AIC) |
| Gaussian | 8  | -355.4372  | -317.3169  | 185.7186  | Second best |
| Spherical | 8  | -354.5857  | -316.4654  | 185.2929  | Third |


**Question:** Which model has the lowest AIC? Is this model significantly better than the others? exponential_model, not significantly better than the Gaussian or spherical models (anova)

---

# Part 7: Model Refinement and Validation

## 7.1 Fine-Tune the Best Model

```{r tune-model}
# Add nugget parameter to the best model
spatial_model_tuned <- update(object = exponential_model,
                             correlation = corExp(form = ~ Longitude + Latitude, 
                                                 nugget = TRUE))

# View summary
summary(spatial_model_tuned)

# Check variogram of tuned model
Vario_tuned <- Variogram(spatial_model_tuned,
                         form = ~ Longitude + Latitude,
                         robust = TRUE,
                         maxDist = 20,
                         resType = "normalized")
plot(Vario_tuned, smooth = TRUE)
```

**TASK:** Fill in the function to update models and the nugget argument.

## 7.2 Cross-Validation

```{r cross-validation}
# Create folds for 5-fold cross-validation
set.seed(123)
Folds <- createFolds(sPlot.Data$X, k = 5)


# Perform cross-validation
CV <- sapply(1:5, function(i) {
  Train <- update(spatial_model_tuned, data = sPlot.Data[Folds[[i]], ])
  Test <- predict(Train, sPlot.Data[-Folds[[i]], ])
  Test - sPlot.Data$Species_richness[-Folds[[i]]]
})

# Test if average deviation is different from 0
t.test(unlist(CV))

# Calculate RMSE
RMSE <- sqrt(mean(unlist(CV)^2, na.rm = TRUE))
print(paste("RMSE:", round(RMSE, 2)))

# Calculate MAE
MAE <- mean(abs(unlist(CV)), na.rm = TRUE)
print(paste("MAE:", round(MAE, 2)))
```

**TASK:** Fill in functions for getting dimensions, updating models, making predictions, and performing t-test.

**REMEMBER**: Root Mean Squared Error (RMSE; i.e., the square-Root of the the mean of the squared residuals) and Mean Absolute Error (MAE; i.e., the mean of the absiklute residuals) are metrics used to evaluate a Regression Model. These metrics tell us how accurate our predictions are and, what is the amount of deviation from the actual values.
---

# Part 8: Model Visualization and Interpretation

## 8.1 Observed vs. Predicted Plot

```{r obs-pred-plot}
# Get predicted values
predicted_values <- predict(exponential_model, sPlot.Data)

# Create plot
ggplot(sPlot.Data, aes(x = Species_richness, y = predicted_values)) +
  geom_point(alpha = 0.5) +
  geom_abline(slope = 1, intercept = 0, color = "red", linewidth = 1) +
  theme_minimal() +
  labs(title = "Observed vs. Predicted Species Richness",
       x = "Observed Species Richness",
       y = "Predicted Species Richness")

```

**TASK:** Fill in the predict function, dataset, data frame for ggplot, x and y aesthetics, and geom for points.

## 8.2 Spatial Map of Residuals

```{r residual-map}
# Add residuals to spatial data
data_sf$residuals <- resid(exponential_model)

# Plot residuals spatially
ggplot(data_sf) +
  geom_sf(aes(color = residuals)) +
  scale_color_gradient2(low = "blue", mid = "white", high = "red", 
                       midpoint = 0) +
  theme_minimal() +
  labs(title = "Spatial Pattern of Model Residuals",
       color = "Residuals")

# The map shows that both positive and negative residuals are scattered across the map --> indicating that the exponential spatial correlation structure accounted for spatial dependence in species richness.

```

**TASK:** Fill in functions to extract residuals and create sf geometry plot.

## 8.3 Check Residual Autocorrelation

```{r check-final-residuals}
# Extract residuals from spatial model
spatial_residuals <- residuals(exponential_model, type = "normalized")

# Moran's I on spatial model residuals
Moran.I(x = spatial_residuals,
        weight = inv_dist_matrix,
        scaled = TRUE,
        na.rm = TRUE)

# Compare to original residuals
cat("\nMoran's I for LM residuals:\n")
Moran.I(x = lm_residuals, weight = inv_dist_matrix, 
        scaled = TRUE, na.rm = TRUE)


summary(gls_model)
summary(spatial_model_tuned)

```

**Question:** Has the spatial correlation in residuals been reduced? By how much? yes - like 50% or so

---

# Part 9: Reporting Results

## 9.1 Model Summary Table

**Fixed Effects:**

| Predictor | Estimate | Std. Error | t-value | p-value | Interpretation |
|-----------|----------|------------|---------|---------|----------------|
| Intercept | 1.3709423 | 0.01560236 | 87.86760 | 0.0000 | baseline richness level at reference conditions |
| Elevation | -0.0239838 | 0.01074326 | -2.23245 | 0.0258 | higher elevation slightly decreases richness |
| Slope | 0.0034574 | 0.00698041 | 0.49530 | 0.6205 | slope not significant |
| SoilClim_PC1 | 0.0030102 | 0.00922744 | 0.32622 | 0.7443 |  PC1 not significant |
| SoilClim_PC2 | 0.0132936 | 0.00411499 | 3.23052 | 0.0013 | PC2 increases richness significantly |


## 9.2 Random Effects and Spatial Structure

**Random Effects:**
- Country random intercept SD: 0.08581584
- Residual SD: 0.1905065

**Spatial Correlation Structure:**
- Type: Exponential (Exponential/Gaussian/Spherical)
- Range parameter: 0.2069689
- Nugget: 0.7251339

## 9.3 Model Performance

- AIC: -398.3018
- BIC: -355.4165
- RMSE: 0.2
- MAE: 0.16
- Reduction in Moran's I: 0.1202 to 0.0571

## 9.4 Write Your Interpretation

*Write a paragraph summarizing your findings:*

1. Which environmental variables significantly affect species richness?
2. What is the direction and magnitude of these effects? 
3. How much spatial autocorrelation was present initially?
4. How well did the spatial model address the autocorrelation? 
5. What are the practical implications of your findings?


*The spatial mixed-effects model showed that elevation is the only significant predictor of species richness, with richness decreasing slightly at higher elevations. Other environmental variables did not have significant effects once spatial structure was accounted for. Initial residuals showed some spatial autocorrelation (Moran’s I = 0.1202), which was reduced by more than half in the spatial model (Moran’s I = 0.0571). This means that the model effectively captured most of the spatial autocorrelation. Overall, the results highlight that elevation plays a modest but significant role in shaping species richness, and that including spatial structure is important for accurate ecological inference in this system. wuup wuup smarty smart nugget nuggets*


# Challenge Exercises

## Challenge 1: Alternative Predictors
Reload the full dataset (`Splot_SppRichness_AllVars.csv`) and include additional environmental variables. Does this change your spatial correlation structure selection?

## Challenge 2: Directional Autocorrelation
Investigate whether spatial autocorrelation is the same in all directions (isotropic) or varies by direction (anisotropic). Use directional variograms.

## Challenge 3: Local vs. Global Models
Compare your global spatial model with local regression techniques (e.g., Geographically Weighted Regression). Which performs better?

## Challenge 4: Prediction Mapping
Create a prediction map showing estimated species richness across Europe based on your spatial model.

---

# References
